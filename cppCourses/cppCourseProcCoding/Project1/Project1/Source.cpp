/*
В результате выполнения данной работы слушатель получает много мелких но необходимых
для дальнейшей работы навыков, поэтому задание построено как последовательность
закомментированных блоков, которые требуется последовательно раскомментировать,
отвечая  при этом на поставленные вопросы.

Примерная последовательность действий при отладке проекта:
1. наберите (исправьте, раскомментируйте нужный фрагмент) исходный текст программы;
2. откомпилируйте (Build/Compile  ***.cpp или Ctrl+F7)
Замечание: этот этап явно вызывать необязательно, но полезно для начинающего
программиста, т.к. позволяет увидеть ошибки (errors) и предупреждения
(warnings), возникающие при компиляции данного конкретного файла;
3. скомпонуйте проект(Build/Build ***.exe или F7)
Замечание 1: этот этап тоже необязателен, но настоятельно рекомендуем, т.к.
позволяет перекомпилировать только измененные файлы и в случае отсутствия
ошибок всегда полезно посмотреть на выдаваемые компилятором замечания;
Замечание 2: перед тем, как строить проект, неплохо убедиться  в том, что
исполняемый код будет содержать информацию для отладчика -
(Build/Configuration Manager.../Configuration - Debug - тип сборки проекта);
4. поставьте на интересующих Вас строках исходного кода остановы(breakpoints) - F9 или
просто кликните левой кнопкой на левой серой полосе окна редактирования;
5. запустите программу в режиме отладки
(Debug/Start... или  F5);

Замечание: для перечисленных выше действий приведены комбинации клавиш и соответствующие
пункты меню, однако во многих случаях гораздо быстрее то же самое можно сделать с
помощью кнопок на Tool Bar, в чем слушатель может преуспеть самостоятельно.

*/

#include  <iostream>		//для использования потоков ввода/вывода

int nTwin = 1;			//глобальная переменная
namespace TwinSpace { int nTwin = 2; }	//переменная объявлена в
										//пространстве имен - TwinSpace

#define	  stop __asm nop	//с помощью макроподстановки задаем "пустую" команду.
										//Эта макроподстановка нужна только для того, чтобы
										//можно было поставить на этой строке точку останова.

int main()
{

	//**********************************************************
	//Задание 1. Работа с отладчиком. Базовые типы данных. Выполняя программу по шагам, 
	//следите за значениями переменных и интерпретируйте результат (помните, что 
	//количество байт, отводимых под int, системо-зависимо).
	//Обратите внимание на разную интерпретацию отладчиком signed и unsigned целых типов 
	//данных, а также на внутреннее представление отрицательных целых чисел.


	char cByte = 'A'; //65 0x41 'A'
	cByte = 0x42;  // 66 'B'
	cByte = 66;   //0x42 'B'
	cByte = -1; // -1dec 0xff 'я'

	unsigned char ucByte = 0x41; // 0x41 'A'
	ucByte = 'B'; // 0x42 'B'
	ucByte = -1; // 255dec 0xff 'я' 

	int iInt = 0xffffffff; // -1 dec 

	unsigned int uiInt = 0xffffffff; //		4294967295 dec 


	float fFloat = 1.f; //		1.00000000 8зн

	double dDouble = 1.;// 		1.0000000000000000 16зн

	stop

	// Выполните фрагмент, приведенный далее. В комментариях отразите,
	// что реально заносится в переменную. Объясните разницу между этим 
	// значением и инициализатором.

	double d = 0.1234567890123456789123456789; //	    0.1234567890123456!8
	float  f = 0.1234567890123456789123456789;// 		0.1234567!9!1


	d = 1.; // 		d	1.0000000000000000	double
	d = 0.999999999999999999999999999999999; //		d	1.0000000000000000	double

	stop

		// В комментариях напишите результат, возвращаемый оператором sizeof для
		// переменной типа wchar_t (ее размер)
		wchar_t cw = L'Ф'; //		cw	0x0424 'Ф'	wchar_t
	size_t n = sizeof(cw); //		n	2	unsigned int
	size_t sizeOfInt = sizeof(uiInt); 	// x64	sizeOfInt	4	unsigned int


	stop


		// **************************************************************
		//Задание 2a. Неявное приведение типов данных.
		//Объясните разницу результата при выполнении (1) и (2):
		//Покажите явно (напишите в коде) преобразования, которые неявно выполняет компилятор

		iInt = 1;
	double dDouble1 = iInt / 3;		// (1)
	double dDouble2 = iInt / 3.;	// (2)
	/*

			double dDouble1 = static_cast<double>(Int)  dDouble1	0.00000000000000000	double
		
			double dDouble2 = static_cast<double>(iInt)/ double  dDouble2	0.33333333333333331	double
	*/
	
									// Ассоциативность операторов.
									// Синтаксис языка C допускает "цепочечное" присваивание
									// (как в строках (1) и (2)). Посмотрев результаты выполнения строк (1) и (2)
									// (значения переменных dDouble, fFloat, nInt, sShort, cByte), определите порядок 
									// выполения присваиваний при цепочечной записи и объясните результат.
									// Расставте скобки, явно определяющие порядок выполнения, как это сделал бы компилятор.
									// Объясните (в комментариях) предупреждения (warnings) компилятора.

	short sShort;
	dDouble = fFloat = iInt = sShort = cByte = 3.3 / 3;			// (1)
	
	/*
		
		dDouble	1.0000000000000000	double
		fFloat	1.00000000	float
		iInt	0x00000001	int
		sShort	0x0001	short
		cByte	0x01 '\x1'	char
	
	*/

	cByte = sShort = iInt = fFloat = dDouble = 3.3 / 3;	  // (2)

	stop

	/*
		
		dDouble	1.0999999999999999	double
		fFloat	1.10000002	float
		iInt	0x00000001	int
		sShort	0x0001	short
		cByte	0x01 '\x1'	char

	*/
	/*

	(dDouble =)6 (fFloat =)5 (iInt =)4 (sShort =)3 (cByte =)2 (3.3 / 3)1;			// (1)

	 (2) warning C4244: '=': conversion from 'double' to 'char', possible loss of data 

	 Тип результата выражения 1 - double, cByte - char. При неявном приведении типа, из 8 байт в 1 байт,может произойти потеря данных,
	 о чем и сообщает компилятор, так же так как char - без плавающей запятой, происходит потеря мантиссы числа.

	 (5) warning C4244: '=': conversion from 'int' to 'float', possible loss of data

	 При конвертации из int в float теряется точность int'а,так как float хранит точно только 7 знаков после запятой


	(cByte =)6 (sShort =)5 (iInt =)4 (fFloat =)3 (dDouble =)2 (3.3 / 3)1;			// (2)
	
	(3)'=': conversion from 'double' to 'float', possible loss of data
	(4)'=': conversion from 'float' to 'int', possible loss of data
	(6)'=': conversion from 'short' to 'char', possible loss of data

	При конвертации в младшие типы (по размеру) может произойти потеря данных.
	
	*/
	
	
																//ниже Вам дан пример "небрежного" использования неявного приведения типов, что может 
																// привести к нежелательным результатам - объясните (в комментариях), к каким?
																// Напишите явно преобразования, которые неявно выполняет компилятор

	iInt = 257;    // iInt 0x101 -> char 0x01
	cByte = iInt; //cbyte char 1 byte - 0x101  происходит потеря старшего бита 	->	cByte	0x01 '\x1'	char



	

	unsigned char cN1 = 255, cN2 = 2, cSum; //0xff+0x02 = 0x01 - выход за размерную сетку

	cSum = cN1 + cN2; // переполнение размера char,потеря старшего бита 		cSum	0x01 '\x1'	unsigned char


	

					  //Сравните предыдущую строчку с приведенной ниже. Объясните (в комментариях),
					  //почему в следующей строке не происходит выход за разрядную сетку
					  // Напишите явно преобразования, которые неявно выполняет компилятор
	int iSum = cN1 + cN2; 
	
	// сумма двух char преобразуется в int, который размером 4 байта,результат помещяется в разрядную сетку int = char1b+char1b (char+char)->int4b 
						  //Напишите, почему при сложении одинаковых значений (одинаковых в двоичной системе) 
						  // в строках (1) и (2) получаются разные результаты
						  // Напишите явно преобразования, которые неявно выполняет компилятор и объясните,
						  // что при этом происходит

	char c1 = 0xff, c2 = 2; // SChar 0xff (-1 dec), 2hex (2dec)
	unsigned char uc1 = 0xff, uc2 = 2; // UChar 0xff (255dec),2hex(2dec)
	int iSum1 = c1 + c2;   //(1) int iSum1 = static_cast<Int>(c1)) + static_cast<Int>(c1)) 		iSum1 = 0x01
	int iSum2 = uc1 + uc2; //(2) int iSum1 = static_cast<Int>(c1) + static_cast<Int>(c1) не происходит переполнения из за неявного преобразования в int

	stop


		// ***********************************************************
		//Задание 2b. Явное приведение типов данных.
		//Проинтерпретируйте результат (значения переменной dDouble) в строке (3)
		// Напишите явно преобразования, которые неявно выполняет компилятор
		int nTmp = 100, nn = 3;
	dDouble = 3.3 + nTmp / nn; // (3) double = (double + (int/int)) ->  double = double + int -> double = double
	//знач
	stop

		//Получите результат без потери точности с помощью оператора явного
		//приведения типа
		//	double dDouble3=...		// (4)

	dDouble = 3.3 + double(nTmp) / nn; 		
	dDouble1 = 3.3 + static_cast<double>(nTmp) / nn; // dDouble	36.633333333333333	double

	stop


		// *******************************************************
		// Задание 3. Область действия, область видимости и
		//				время существования переменных

		//   В этом фрагменте фигурируют четыре переменных с одним и тем же именем 
		// nTwin - одна глобальная, вторая определена в своем пространстве имен, 
		// (определены выше в начале модуля) третья - локальная внутри функции main(), 
		// четвертая - вложенная локальная внутри блока. 
		//   В данном задании требуется в выделенных местах фрагмента определить, к какой 
		// из четырех переменных идет обращение, а также факт существования и видимости 
		// для всех четырех, заполнив приведенные в задании таблицы 
		//	Для выполнения задания рекомендуется пользоваться окнами "Locals" и "Watches"
		// Подсказка: - в окно "Watches" можно поместить как nTwin
		//			так и ::nTwin, впрочем как и TwinSpace::nTwin

		//		::nTwin	1	int
	nTwin = 100;  //global    //		::nTwin	100	int
	TwinSpace::nTwin = 300;  //namespace 		TwinSpace::nTwin	2	int

	nTwin++; //global   ::nTwin	101	int
	// Обратите внимание на небольшой "глюк" отладчика. Хотя локальная переменная nTwin
	// до следующей строки еще не определена (и формально даже не существует), но место
	// под нее в стеке функции main уже выделено (и там мусор). Если теперь в  окно 
	// "Watches" поместить просто nTwin, то отладчик будет показывать значение этой, еще 
	// не объявленной локальной переменной (что-то вроде -858993460 или 0xcccccccc), 
	// хотя должен формально показывать значение глобальной переменной, объявленной ранее.
	// Компилятор при этом все вычисляет верно.
	// Если надо увидеть именно значение глобальной переменной, то надо явно указать в окне
	// "Watches" глобальную область видимости, т.е. написать там ::nTwin.
	// Примечание: вот еще один аргумент за то, чтобы не создавать конфликты имен.
	int nTwin; //local main 		nTwin	??	int
	nTwin = 200; // local main 		nTwin	200	int
	::nTwin++; //global 		::nTwin	102	int
	{
		int nTwin; // local nTwin ?? int
		nTwin = -1; //local codeblock	nTwin -1 int
		::nTwin++; //global 		::nTwin	103	int
		TwinSpace::nTwin++; //namespace  		TwinSpace::nTwin	301	int

	}

	nTwin--; //local main  		nTwin	199	int


	stop

	// *******************************************************
	// Задание 4. Спецификатор класса памяти - static
	// а) Для каждой итерации цикла напишите значения пременных nLocal# и nStatic#.
	// б) Напишите, когда выполняется инициализация обеих переменных?
	// в) Поясните (в комментарии) разницу между способом инициализации 
	//     переменных nStatic1 и nStatic2 и поясните побочный эффект, 
	//     влияющий на переменную nLocal2.

	for (int i = 0; i<3; i++)
	{
		static int nStatic1 = 100; // - сюда во второй раз компилятор не заходит
		int nLocal1 = 100;
		int nLocal2 = 200;
		static int nStatic2 = nLocal2++ * 2; // - сюда во второй раз компилятор не заходит
		nStatic1++;
		nStatic2++;
		nLocal1++;
		stop
			
			/*
				1st iter:

				nStatic1	101	int --init
				nStatic2	401	int --init
				nLocal1 	101	int --init
				nLocal2 	201	int --init

				
				2nd iter:

				nStatic1	102	int
				nStatic2	402	int
				nLocal1  	101	int --init
				nLocal2	    200	int --init

				3rd iter:

				nStatic1	103	int
				nStatic2	403	int
				nLocal1	    101	int --init
				nLocal2	    200	int --init



			*/

	}
	// Напишите:
	//   а) как изменилось поведение пременной nStatic1?
	//   б) как эта переменная ИНИЦИАЛИЗИРОВАНА ?
	for (int i = 0; i<3; i++)
	{
		static int nStatic1; //здесь только обьявление, инициализация происходит при каждом заходе в цикл
		nStatic1 = 100;
		int nLocal1 = 100;
		nStatic1++; // 101 101 101
		nLocal1++; // 101 101 101
		stop

	}



	// *******************************************************
	// Задание 5. Перечисления - enum
	// Обратите внимание на явную и неявную инициализацию констант
	// Выполняя задание по шагам, следите за значениями, которые
	// принимает переменная myColors


	enum eColors
	{
		BLACK,
		BLUE,
		GREEN,
		RED = 5,
		YELLOW,
		WHITE = RED + 4
	};

	eColors   myColors;	//объявление переменной типа eColors 
	myColors = BLACK; // 0
	myColors = BLUE; // 1 
	myColors = GREEN; // 2
	myColors = RED; // 5
	myColors = YELLOW; // 6 



	myColors = WHITE; // 9

	int nnn = BLACK; //любой целочисленной переменной можно присвоить
					 //значение из списка инициализирующих значений
	stop
					 //Именованные константы можно использовать в выражениях:
	nnn = BLUE | YELLOW; //7

	 

	//Раскомментируйте следующую строку и обратите
	//внимание на  ошибку при компиляции 
	 myColors = BLUE;	//модифицируйте выражение таким образом, чтобы компилятор не выдывал ошибки

	 stop

	// Выполните следующее присваивание НЕ меняя перечисление и тип переменной myColors?

	 myColors = static_cast<eColors>(123);

	 


		// *******************************************************
		// Задание 6.1 Логический тип bool
		// Выполняя задание по шагам, следите за значениями
		// переменной b и интерпретируйте результат. Напишите эти значения в комментариях

	int nNumber = 1;
	bool b = (nNumber != 0); // true
	b = (nNumber == 0); // false
	b = (nNumber > 0); // true
	b = (nNumber > 1); // false
	b = 5; // true

	
		   //Вы всегда можете преобразовать логическое значение к целому
		   //явно или компилятор может это сделать самостоятельно (неявно)
		   //Обратите внимание: как интерпретирует значения логических переменных компилятор?
	int tmp = b + 1; // 1 (true) + 1 = 2

	stop
					 //Задание 6.2 В Григорианском календаре (которым мы все пользуемся) високосный год
					 // определяется по следующему алгоритму: високосным является каждый четвертый год,
					 // но каждый сотый високосным не является, при этом каждый 400-й год все таки 
					 // високосный. Т.е. 1823 - не високосный, 1824 - високосный, 1900 - не високосный,
					 // 2000 - високосный.
					 // Напишите фрагмент кода, такой что:
					 // логическая переменная isLeapYear принимает значение true, если год, заданный
					 // переменной year - високосный.
					 // Примечание: НЕ НАДО пользоваться операторами if-else, тернарным оператором и switch
					 //             НАДО написать логическое выражение в одну строку.
	{
		int year = 1823;
		//int year = 1824;
		//int year = 1900;
		//int year = 2000;

		//Вычислили значение 
		bool isLeapYear = ((year % 4 == 0 && year % 100 != 0) || (year % 400 == 0));
		// проверили значение в отладчике
		stop
	}

	// *******************************************************
	// Задание 7. Модификатор const и переменные

	{
		//Раскомментируйте следующие две строчки и объясните (в комментариях)
		//ошибки при компиляции 

		//	const int nN; // nN unmutable value,инициализация констант должна происходить при обьявлении
		//		nN = 1; 
	}



	// ********************************************************
	//Задание 8. Логические условные операторы и операторы отношения.

	//Задание 8.1 Напишите фрагмент кода, который переводит код символа, 
	//хранящийся в переменной ch в противоположный регистр.
	//Требуется предусмотреть проверку ситуации, когда пользователь ввел цифру
	//или нажал другую клавишу, которой символ не соответствует
	//Подсказка: работаем только с символами английского алфавита, для которого в таблице
	// кодов ASCII код каждой буквы нижнего регистра на 0x20 больше кода 
	// соответствующей буквы верхнего регистра.
/*	{
			// Сформируйте значение переменной ch с помощью потока ввода
			char ch;
			std::cout << "Enter some letter: ";
			std::cin >> ch;
			if (ch > 'a' && ch < 'z') {
				ch -= 32;
			}
			else if (ch > 'A' && ch < 'Z') {
				ch += 32;
			}
			else {
				std::cout << "You entered wrong symbol" << std::endl;
			}
			std::cout << ch << std::endl;
			//... изменили регистр
			// здесь проверили в отладчике значение или вывели "эхо" на экран
			stop
	}
*/
	//XOR realization

	{
		char ch;
		std::cout << "Enter some letter: ";
		std::cin >> ch;

		if ((ch >= 'a' && ch <= 'z') || (ch >= 'A' && ch <= 'Z')) {
			ch = ch ^ 0x20;
		}
		else {std::cout << "You entered wrong symbol" << std::endl;}

		std::cout << ch << std::endl;



	}


	//Задание 8.2 Напишите фрагмент кода, который реализует с помощью if (if/else)
	//следующую логику: если x меньше или равен 0, y=0
	//если x больше 0 но меньше 1, то y=x,
	//если x больше или равен 1, то y=1
	//Подумайте: какого типа должны или могут быть x и y?
	{
		int x = 1;
		int y = 2;

		if ((x > 0) && (x < 1)) {
			y = x;
		}
		else if (x >= 1) {
			y = 1;
		}


	}

	//Задание 8.3 Напишите фрагмент кода, который реализует с помощью switch
	//следующую логику: в переменной cInput типа char дано значение символа,
	//введенного любым способом.
	//Если введен символ 'y' (т.е. yes) в любом регистре, то присвоить
	//переменной у значение переменной x
	//Если введен символ 'n' (т.е. no) в любом регистре, то присвоить
	//переменной у значение (x * 2)
	//Если любой другой симол, то вывести сообщение об ошибке
	{
		int x = 0, y = 0;
		char ch;
		std::cout << "Enter yes(y) or no (n): ";
		std::cin >> ch;
		switch (ch)
		{
		case 'y':
		case 'Y':
			y = x;
			break;
		case 'n':
		case 'N':
			y = x * 2;
			break;
		default:
			std::cout << "You entered wrong number" << std::endl;
			break;
		}
	}
	// ********************************************************
	//Задание 9. Циклы.

	//Задание 9.1 Напишите фрагмент кода, который реализует с помощью for
	//следующую логику: найти сумму заданного диапазона целых чисел.
	//Введите границы с помощью потока ввода или с помощью средств отладки.
	//Предусмотрите защиту от ввода нижней границы больше, чем верхней.
	{

		//сформироыать границы диапазона
		
		int minPoint = 0;
		int maxPoint = 0;
		int summOfRange = 0;

		std::cout << "Enter the lower range limit : ";
		std::cin >> minPoint;

		std::cout << "Enter the upper range limit: ";
		std::cin >> maxPoint;

		//проверить корректность значений

		// вычислить сумму
		// проверить в отладчике значение

		if (minPoint > maxPoint) {

			std::cout << "Wrong range values";
		}
		else {
			for (int i = minPoint; i < maxPoint; i++) {

				summOfRange += i;

				stop
			}
			std::cout << "Summ of range is: " << summOfRange << std::endl;

			}



	}


	//Задание 9.2 Напишите фрагмент кода, который реализует с помощью do-while
	//следующую логику: на каждой итерации цикла ввести с консоли целое значение
	// и покинуть цикл, если значение удовлетворяет условию: 
	// значение больше или равно 10 и четное.
	//Замечание: проверка на четность с использованием операции остатка от деления
	//нацело генерирует очень неэффективный код. Попробуйте реализовать альтернативный
	//вариант.

	{

		do { 

		std::cout << "Enter n: "; 
		std::cin >> n;

		} while ((n<10) || (n & 1));

	}


	//Задание 9.3 Напишите фрагмент кода, который реализует с помощью while
	//следующую логику: исходно int x = 0; 
	//на каждой итерации x=x+1, sum=sum+1/x
	//найти значение x, при котором sum>1.7

	int x = 0;
	float sum = 0;

	while (sum<1.7)
	{
		x++;

		sum = sum + static_cast<double>(1) / x;

		
	}
		std::cout << x;

		stop

	return 0;//код завершения приложения
}	// Конец функции main()

