/*************************************************************
Практическое занятие №2. Побитовые операторы.
Директивы препроцессора.
Указатели.
*************************************************************/

#include <iostream>
#include <tchar.h>
//#include <cmath>

using namespace std;

#define	  stop __asm nop	//с помощью директивы препроцессора задаем
//макроподстановку
/***************************************************************
Задания, отмеченные * , не являются обязательными!
***************************************************************/

int _tmain()
{
	// ********************************************************
	//Задание 1. Побитовая арифметика (and, or, xor, not), сдвиги.
	//1.1
	{		 //Задайте значение y, например, с помощью потока ввода

			  //С помощью побитовых операторов и операторов сдвига выведите значение "y"
			  //на консоль в двоичном виде, например:
			  //если y==9, то
			  // а) 0 0 0 0 ...   0 0 1 0 0 1 (количество двоичных цифр зависит от платформы)



			  //или пропустите незначащие нули - б) 1 0 0 1
		//a task

		int x;

		cout << "Please enter value of x:";
		cin >> x;

		cout << "Binary representation of " << x << " is : ";


		for (int i = 31; i >= 0; i--) {

			int checker = x >> i;

	/*		if (checker & 1) {

				cout << " 1 ";
			}
			else  {
				cout << " 0 ";
			}*/
			cout << ((checker & 1)? 1 : 0);
		}
		


		//b task

		int y;

		cout << "\nPlease enter value of y:";
		cin >> y;

		cout << "\nBinary representation of " << y << " is : ";

		bool isOne = 0;

		for (int i = 31; i >= 0; i--) {

			int checker = y >> i;

		if (checker & 1) {isOne = 1;}

		if (checker & 1 && isOne) {
			cout << " 1 ";
				}
		else if (isOne) {
			cout << " 0 ";
			}
		}

		stop

	}


	//1.2 Дана целая переменная
	{
	//Задайте значение y, например, с помощью потока ввода

	//"Сдвиньте" все единицы в этой переменной вправо, например:
	//было:   0100 1111 0000 0000 0110 1111 0000 0010
	//стало:  0000 0000 0000 0000 0000 1111 1111 1111
	//Реализовать задачу посредством одного цикла!



		int y;

		cout << "\nPlease enter value of y:";
		cin >> y;

		int newY = 0;

		for (int i = 31; i >= 0; i--) {
			
			int checker = y >> i;

			if (checker&1) {

				newY = (newY << 1) | 1;
			}
		}

	///	cout << hex << newY << endl;

		stop
	}


	//1.3* Какие операции следует применить к заданному ниже операнду sNum для
	//того, чтобы переменная sRes приняла требуемое значение?
	//Замечание 1: значения подобраны таким образом, что в каждом случае достаточно
	//использовать один оператор (и при необходимости маску) 
	//Замечание 2: посредством оператора xor (подобрав соответствующую маску)
	//можно получить любое значение => этот оператор предполагается использовать
	//в том случае, когда все остальные уже "не спасают" 
	{
		short sNum = 0x8008;
		short sRes;

		//0x7ff7

		sRes = ~sNum;


		//0x8ff8

		sRes = sNum | 0x0ff0;

		//0x0008

		sRes = sNum & 0x8;

		//0x7f08

		//sRes = ((~(sNum >> 8)) << 8) | (sNum & 0xff);

		sRes = sNum ^ 0xff00;

		//0xf001

		sRes = sNum >> 3;

		//0x0010

		sRes = static_cast<unsigned short>(sNum) >> 11;//!!!!!!!!!!!!!!!!!!!!!!!!


		
	}


	// ********************************************************
	//Задание 2. Директивы препроцессора

	//2.1. Использование "математических" макросов стандартной библиотеки:
	//в заголовочном файле <cmath> (который в свою очередь включает старый
	//файл math.h) определены часто используемые математические
	//константы, например M_PI. Воспользуйтесь этой константой для
	//вычисления длины окружности.
	//Обратите внимание: определения констант в свою очередь тоже заключены
	//в директивы условной трансляции. Что еще, кроме подключения заголовочного
	//файла, требуется сделать???

	#define _USE_MATH_DEFINES
	#include <math.h>
	
	{
		double radius = 3.2;

		double perimetr = 2 * M_PI * radius;


	}



	//2.2.Макросы с параметрами.
	//2.2.1 Напишите свою макроподстановку LENGHT которая вычисляет длину окружности.
	// протестируйте написанный макрос для следующих ситуаций:
	#define LENGTH(radius) (2*M_PI*(static_cast<float>(radius)))
	{
	
		float l1 = LENGTH(1 + 2); // должно быть 18.8495...
		float l2 = 1 / LENGTH(2); // должно быть 0.07957...
		stop
	}








	//2.2.2* определите макрос MAX(A, B)  для вычисления б'ольшего
	//значения из двух.

	#define MAX(a,b) (a>b ? a : b)

	//Используйте макрос следующим образом. Следите за изменением
	//значений переменных k, i, j. Объясните результат.
	//Постарайтесь убрать побочные эффекты.
	//Отметьте случаи, когда избежать побочных эффектов невозможно
	
	int i = 10, j = 12, k;
	k = MAX(i, j); // k == 12 i = 10 j = 12
	k = MAX(j, i) * 2; // k == 24 (j * 2) i = 10 j = 12
	k = MAX(j, i+3); // k = 13 (i+3 == 13) i = 10 j = 12
	k = MAX(i--, j++); // k = 13 (x-- !lvalue ?)  i = 9  j =14

	k = MAX(--i, ++j); //k = 16


	//2.2.3 определите макрос EXCHANGE(X, Y)  для перестановки
	//двух объектов типа int в памяти местами. Проверьте для приведенного
	//фрагмента. Подумайте, что будет делать макроподстановка, если
	//переставляемые значения разного типа???

    //#define EXCHANGE(x,y) x = x + y; y = x - y; x = x - y;
//#define EXCHANGE(x,y) 
//
//	int x1=1, y1=-1;
//	EXCHANGE(x1,y1);
//
//
//	int x2=100, y2=-100;
//
//	EXCHANGE(x2,y2);
//
//	int x3 = 200;
//	double y3 = 300.5;
//
//	EXCHANGE(x3, y3); // неявное преобразование y3 = 300; x3 = 199.5;
//	stop


	//2.3. Директивы условной трансляции
	//Выполняя следующий фрагмент, посмотрите, какое
	//значение принимает переменная iNN. Что нужно сделать
	//для того, чтобы результат был равен 0? 1? 2?

	int iNN;
	#if defined NNN && defined MMM // #define NNN,MMM
	iNN = 0;

	#elif defined MMM // #define MMM
	iNN = 1;
	#elif defined NNN // #define NNN
	iNN = 2;

	#else  // MMM && NNN not defined
	iNN = -1;
	#endif

	stop




		//Задание 2.4. Загляните в Project/Properties -> диалоговая панель
		//- Property Pages/C\C++/Preprocessor/Preprocessor definitions.
		//В опциях командной строки в зависимости от мишени сборки проекта
		//(Debug или Release) может быть определено с помощью ключа /D
		//имя _DEBUG. С помощью директив условной
		//трансляции напишите фрагмент кода, который в зависимости от типа
		//мишени выводит с помощью cout разный текст на консоль. Проверьте
		//при разных мишенях сборки.

		//Пусть
		//для мишени Debug в процессе выполнения данного участка
		//кода на экран выводится информация об
		//имени файла, номере строки с функцией вывода, дате и времени 
		//компиляции файла, содержащего данную функцию вывода,
		//а также имя функции, содержащей данную строку.

#if defined _DEBUG 

		cout << "Current file: " << __FILE__ <<
		"\nLine: " << __LINE__ <<
		"\nTime: " << __TIME__ <<
		"\nCurrent Function: " << __FUNCTION__;

	//Для мишени Release должна быть просто выведена строка
	//"Release configuration!"

	//Подсказка: для получения нужной информации введите в инструментальном
	//окне 'Index' справочной системы следующую ключевую фразу:	Predefined Macros

	//Подсказка: мишень сборки проекта можно
	//поменять следующим образом - Build/Configuration Manager/Configuration

#else
		cout << "Release configuration!";

	#endif


	//Задание 2.5.* Управляя определенностью идентификатора _UNICODE и используя
	//возможности заголовочного <tchar.h>, определите и проинициализируйте переменную,
	//которая может становиться как однобайтовой, так и расширенной без 
	//изменения исходного текста.
	//С помощью отладчика проверьте результат.
//
//	#undef _UNICODE
//
//	#if defined _UNICODE 
//
//	typedef wchar_t NSChar;
//
//#else
//
//	typedef char NSChar;
//
//#endif

	TCHAR someLetter = 'A';

	int sizeOfNSChar = sizeof(someLetter);

	cout << "\nSize of NSChar type is: " << sizeOfNSChar <<" byte";

	stop



		// ********************************************************
		//Задание 3.Заголовочные файлы. Директива #include
		//3.1.Создайте и подключите к проекту два заголовочных файла 1.h и 2.h
		//В каждом заголовочном файле объявите перечисление с одинаковыми именами
		//констант, но сопоставьте именованным константам разные значения, например:
		//1.h - enum MyEnum{My1, My2, My3};  . 2.h - enum MyEnum{My1=5, My2, My3};
		//С помощью директив условной трансляции в DEBUG-версии пользуйтесь значениями
		//констант из 1.h, а в RELEASE-версии значениями констант из 2.h

#if defined _DEBUG

#include "Header.h"


#else

#include "Header1.h"

#endif

		MyEnum First = My1;
		MyEnum Second = My2;
		MyEnum Third = My3;





	// ********************************************************

	//Задание 4. Указатели
	//Объявите объекты разных типов и проинициализируйте их.
	//Объявите указатели соответствующих типов и проинициализируйте их
	//адресами заданных объектов.
	//Выполняя задание, с помощью отладчика посмотрите, какие значения
	//будут присвоены переменным-указателям и на что эти указатели
	//"указывают"


	int a = 1;
	char b = 'A';
	bool c = 1;
	double d = 1.1;

	int* aPtr = &a; // + aPtr	0x0040fb10 {1}	int *
	char* bPtr = &b; // +		bPtr	0x0040fb07 "AММММММММ\x1"	char *
	bool* cPtr = &c;// +		cPtr	0x0040fafb {true}	bool *
	double* dPtr = &d;//+		dPtr	0x0040fae8 {1.1000000000000001}	double *

	stop





		//Задание 4а. Объявите указатель на тип char и проинициализируйте
		//его адресом строкового литерала. Присвойте переменной типа char значение
		//любого элемента строки.
		//Проверьте - возможно ли присвоить какое-либо значение по адресу,
		//задаваемому указателем?

		const char* strValPtr = "qwerty";

		char someElement = strValPtr[1];
	//	strValPtr[1] = 'W';
	//	*strValPtr = "ytrewq"; "const char" cannot be assingned to an entity of type char*




	//Задание 5. Арифметика указателей. Операция разыменования указателя.
	//Выполняя задание, следите за изменением значений
	//указателей и значений объектов, на которые они указывают.
	//Интерпретируте наблюдаемые результаты

	{
	int nAr[3] = {1,3}; //+	nAr	0x003ff5f4 {1, 3, 0}	int[3]
	int* pn = &nAr[0]; // 		+		pn	0x0036f7dc {1}	int *
	(*pn)++; //		*pn	2	int
	pn++;   // 		+		pn	0x0036f7e0 {3}	int *

	char cAr[]={'A','B','C','D'};//+		cAr	0x003ff5dc "ABCD...	char[4]
	char* pc = &cAr[0]; //		+		pc	0x003df520 "ABCDММММММММ<х="	char *
	(*pc)=(*pc)+5; // 		*pc	70 'F'	char
	pc=pc+3; // 	    	pc	0x0036f7c7 "DММММММММач6"	char *

	double dAr[3]={1.0,2.0}; // +		dAr	0x003ff5b0 {1.0000000000000000, 2.0000000000000000, 0.00000000000000000}	double[3]
	double* pd1 = &dAr[0]; // +		pd1	0x003ff5b0 {1.0000000000000000}	double *
	double* pd2 = pd1; // +		pd2	0x0036f798 {1.0000000000000000}	double *
	(*pd2)+=2; // 		*pd2	3.0000000000000000	double
	pd2+=2; //+		pd2	0x0036f7a8 {0.00000000000000000}	double *

	//Объясните результат выполнения операции
	//вычитания двух указателей
	pd1 = &dAr[0]; // +		pd1	0x0036f798 {3.0000000000000000}	double *
	pd2 = &dAr[1];// +pd2	0x0036f7a0 {2.0000000000000000}	double *
	int nNumber=pd2 - pd1; // 		nNumber	1	(int (0x0036f7a0 - 0x0036f7a0) / sizeof(double)) 

	//Сравните указатели pd2 и pd1 и с помощью cout
	//выведите результаты сравнения.

	const char* comparationRes = (pd2 < pd1) ? "pd1<pd2" : "pd2>pd1";

	cout << "\nResult of comparation between pd1 && pd2 :" << comparationRes;

	stop
	}

	//Задание 6. Явное преобразование указателя. Иногда возникает
	//необходимость одни и те же данные интерпретировать по-разному,
	//например, целое можно представить как совокупность четырех
	//байтов и работать с каждым байтом по отдельности. Для этого
	//нужно иметь возможность "указывать" как на целое, так и на байт.
	//Следовательно, возникает необходимость явного преобразования
	//указателя.
	//Подсказка: для правильной интерпретации этого задания воспользуйтесь
	//возможностями отладчика представлять данные в интересующем
	//Вас виде (в данном случае - в шестнадцатеричном) - для
	//этого используйте правую клавишу мыши,находясь в окне
	//переменных и изменяйте пункт - Hexadecimal display

	unsigned int nObject5=0x55667788;
	unsigned int* pnObject5=&nObject5;

	//Раскомментировав следующую строчку кода, обратите внимание
	//на сообщение компилятора - он не считает преобразование
	//"легальным" (безопасным)
	unsigned char* pucObject5;
	//	pucObject5=static_cast<unsigned char*>(pnObject5);	//(1)
	pucObject5=reinterpret_cast<unsigned char*>(pnObject5);	//а такое
	//преобразование - целиком на совести программиста.
	//Его можно применять, только четко представляя себе
	//результат преобразования (2)

	//Откомментируйте следующие строчки сс==..., p - изменился? *p=...

	char cc = *(pucObject5++); //cc	0x88 '€'	char
							   //pucObject5	0x002cf809 "wfUММММММММ\x1"	unsigned char *
	cc = (*pucObject5)++;// cc	0x77 'w'	char
						 //pucObject5	0x002cf809 "xfUММММММММ\x1"	unsigned char *
	cc = ++*(pucObject5); //cc	0x79 'y'	char
						  //pucObject5	0x002cf809 "yfUММММММММ\x1"	unsigned char *
	cc = *(++pucObject5);//cc	0x66 'f'	char
						 //pucObject5	0x002cf80a "fUММММММММ\x1"	unsigned char *
	stop
	
	//Задание 7. Void-указатель.
	//Выполняя задание, посмотрите - какие значения присваиваются
	//void-указателю. Обратите внимание: средствами отладчика Вы
	//не можете посмотреть значения, на которые "указывает"
	//void-указатель
	void*	pVoid;	//объявление void-указателя
	int	nObject3=5;
	char cObject3='A';
	int*	pInt = &nObject3;
	pVoid=&nObject3;   // 5
	pVoid=&cObject3;  // 'A'	
	pVoid=pInt;      // 5	


	stop
	//Прежде, чем раскомментировать следующую строчку, вспомните:
	//что нужно сделать, чтобы выражение стало корректным
	pInt=static_cast<int*>(pVoid);

	//Что нужно сделать для того, чтобы следующее закомментированное выражение
	//стало корректным?
	{
	const int n = 1;
	const void* v_ptr = &n;//????объявить слева void-указатель
	}



	//7a. При выполнении следующего фрагмента посмотрите, какие неприятности
	//могут Вас ожидать при явном приведении типа void-указателя,
	//который в момент времени (1) указывает на double, к типу
	//указателя на int (2)

	double dObject3 = 33.33;
	pVoid = &dObject3;	//(1) 		pVoid	0x0042f680	void *

	int nTmp = *(static_cast<int*>(pVoid) ); //(2)  		nTmp	1889785610	int
	stop

		//Задание 8*. Модификатор const. В каждом из заданий
		//объявите указатель требуемого вида. Посредством каждого
		//указателя попробуйте:
		//получить значение по адресу
		//записать новое значение по адресу
		//модифицировать указатель

		//Задание 8a. Указатель является константой.

		char cChar = 'A';
		char* const pc = &cChar;
		*pc = 'B';

		// pc++ - нельзя для константного указателя



	stop


	//Задание 8б. Указываемое значение является константой.

	 char cChar1 = 'A';
	const char* pc1 = &cChar1;

	//*pc1 = 'B'; - нельзя изменять константу

	pc1++;

	stop

	
	//Задание 8в. И указатель, и указываемое значение
	//являются константами.

	 char cChar2 = 'A';
	const char* const pc2 = &cChar2;

	//*pc1 = 'B'; - нельзя изменять константу

	// pc1++; - и константный указатель тоже нельзя менять


	stop


	//Задание 8г. Указатель на переменную, объявленную с
	//ключевым словом const.
	const int nN = 1;

	//Объявите указатель и проинициализируйте его выражением - &nN

	const int* pnN = &nN;

	stop


	
	//Задание 9.При выполнении задания обратите внимание на то,
	//как наглядно отладчик "раскрывает" конструкции типа
	//"указатель на указатель" и на способы получения конечного
	//объекта по таким "иерархическим" указателям
	int	n1=1;

	//Объявите указатель pn и проинициализируйте его так, чтобы он
	//"указывал" на n1

	int* pn = &n1;

	//Объявите указатель ppn и проинициализируйте его так, чтобы он
	//"указывал" на pn

	int** ppn = &pn;


	//Объявите указатель pppn и проинициализируйте его так, чтобы он
	//"указывал" на ppn

	int*** pppn = &ppn;

	//С помощью указателей pn, ppn и ppn получите значение объекта n1
	//и присвойте его n2

	int resOfPtr = (*pn);

	resOfPtr = *(*ppn);

	resOfPtr = ***pppn;


	int n2 = resOfPtr;


	stop
	



	return 0;
}//end main
